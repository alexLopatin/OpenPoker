# OpenPoker
## Предисловие
Данный проект был написан на C# .Net core 3.1 на IDE Visual Studio 2019. Выбирать фреймворк для backend'a долго не пришлось: совсем недавно
(в декабре 2019) Microsoft предложили новую версию ASP.NET core 3.1, было интересно, что добавили нового, но основной причиной было увеличение
количества поддерживаемых ОС, таких как Ubuntu 16.04 и Debian 9. Вообще киллер фича .Net core 3 состоит в возможности размещения приложений
ASP.NET на серверах с ОС на базе ядра Linux (не на всех конечно, но как можно понять из предыдущего предложения, этот список увеличивается).
Вполне возможно что в скором времени .Net увеличит свою долю в рынке, так как в среднем хостинг сервера на Windows Server обходится несколько дороже, чем 
на серверах с ОС Linux.
(это наверное одна из главных причин, почему многие компании не рассматривали .Net как вариант для бэкенда).
Помимо этого обновили библиотеку SignalR, было интересно разработать мультиплеерную игру с её использованием. Ну и также хотелось посмотреть на
EF core - но он, вроде как, не сильно изменился по сравнению с EF .Net 4.8.
Еще хочу попробовать систему авторизации/аутентификации Identity Core, которая также была относительно недавно обновлена.
Было также желание изучить react, и вроде тут он неплохо вписался бы, но я решил обойтись без него, но возможно как-нибудь перепишу фронтенд используя его.
В качестве базы данных использован MS SQL 2019.

## Интерфейс
Данный раздел будет разбит на два подраздела: что уже реализовано, и то что еще не реализовано или что еще нужно поменять или вообще полностью переделать.
### Готовый интерфейс
Пользователя встречает страница, на которой находится большая кнопка с надписью "Play poker". При нажатии на неё есть два варианта: либо пользователь
авторизован, либо нет. Во втором случае перенаправляем его на страницу авторизации и приходим к первому случаю, после этого перенаправляем к контроллеру-действию, который
отвечает за собственно нахождение стола для пользователя. Также, есть возможность не пользоваться системой автоматического подбора игр и зайти
в список комнат. Рассмотрим список комнат: в нем, как ни странно, находится список комнат с количеством занятых мест, так как количество комнат может
быть очень большим, то было решено разбить их на страницы, внизу есть их список, и можно просмотреть любую страницу из списка комнат.
![Список комнат](/Readme/2.png)
Сама игровая комната представляет из себя нечто похожее на реальный игровой стол: 6 мест для игроков, на столе лежит колода из карт, можно посмотреть ставку каждого игрока. 
При действии игрока высвечивается, какое именно действие он сделал. Когда игроку нужно сделать действие, представляется небольшое меню с одним ползунком
и двумя кнопками: Send и Fold. Ползунок отвечает за ставку, Fold за пас, Send за решение в зависимости от игрока (в покере есть несколько
вариантов действия: Call, когда ты соглашаешься со ставкой, который сделал другой игрок; Check, когда ты не меняешь свою ставку; Bet или raise -
когда повышаешь ставку). Если пользователь в роле admin, то он может сделать всякие админские штучки, типа просмотра карт игроков или
их кика из комнаты.
![Игровой стол](/Readme/1.png)
Также есть возможность посмотреть реплеи матча через контроллер Replay. Сервер отправляет данные по данному матчу, 
а код на Java Script'е в браузере клиента имитирует в хронологическом порядке действия, которые происходили в этом матче.

### _не_ Готовый интерфейс
Вообще говоря различных правил игры в покер довольно много: Техасский холдем, Омаха, Дро-покер. И по нажатию на кнопку "играть" хотелось бы
открыть меню с выбором конкретной разновидности покера. Также надо было бы доработать интерфейс администратора (не только в комнате, 
но и вообще, в том числе возможность следить за _подозрительными_ игроками). Помимо этого необходимо сделать страницу пользователя,
на которой бы была расположена его статистика, как например допустим его винрейт или общее количество выигранных или проигранных фишек.
Ну и возможно график по дням, сколько он выиграл/заработал. Еще хотелось бы иметь чат внутри комнаты, ну и побольше всяких интерактивных 
возможностей типа смены места и т.д. Также было бы неплохо сделать таблицу лучших игроков в сезоне, в году или за все время (по нескольким
показателям, допустим по выигранному кешу или количеству игр). Еще можно сделать систему пользовательских турниров, где пользователь может
запланировать турнир на какое-то время, выбрать определенную сетку и прочее. Ну и вроде на этом все: остались несколько предложений, типа 
добавления в друзья или передачи сообщения, но мне они кажутся сомнительными, мало кто вообще на подобных сервисах пользуется месседжингом,
когда есть гораздо лучшие аналоги (Discord, Telegram, и т.д.).
Полный чек-лист со всеми реализованными/нереализованными идеями:
- [ ] Добавить меню с выбором конкретной разновидностью покера;
- [ ] Добавить личные страницы пользователей с их статистикой;
- [ ] Добавить таблицу лучших;
- [ ] Добавить чат в комнату;
- [ ] Добавить валидацию аккаунта по почте (немного не про интерфейс, но это единственный чек-лист на данный момент);
- [ ] Расширить возможности администрирования ресурса.

## Архитектура приложения

Есть класс Game, в котором собственно игра и моделируется. У него есть несколько событий OnGameUpdate, OnGameLog, OnGameClose. Как понятно из 
названия, событие OnGameUpdate вызывается при обновлении состояния игры, тем самым говоря серверу о том, что пора бы отослать клиентам
новые данные об игре. OnGameLog вызывается при необходимости фиксации изменений в лог (или реплей) матча (OnGameUpdate и OnGameLog разделены,
поскольку вообще говоря данные необходимые для отправки клиентам и данные для протоколирования могут существенно отличаться). Ну и OnGameClose
свидетельствует о закрытии комнаты (случается при отсутствии игроков в комнате), возможно логику закрытия комнаты нужно перенести вверх по
иерархии, так как не Game должен решать, когда ему закрываться. Есть интерфейс IPlayer, в котором есть свойства и методы для работы с конкретным
игроком (как например получение действия через DoBet или просто увидеть карты игрока). IPlayer реализуется BotPlayer'ом и NetworkPlayer'ом,
и как понятно из названия, один класс реализует поведение бота, а другой класс реализует живого клиента, подключенного посредством сети 
(или HTTP long polling или WebSocket в зависимости от того, что будет в наличии у клиента)
через SignalR. Также есть класс UpdateComposer,
который собирает все обновления в игре в единый объект и передает их в аргументы событий, в частности этот класс решает, кому какую
информацию стоит передать (возможно логику этого класса тоже предстоит поменять). В проекте используется паттерн [внедрения зависимостей](https://en.wikipedia.org/wiki/Dependency_injection)
(Dependency Injection, DI). Поддержка DI уже встроена в ASP.NET Core. Класс Server реализуется паттерном Singleton и добавляется в список
сервисов зависимостей. Основная задача этого класса это отправка сообщений клиентам. Для общения клиента с сервером есть класс RoomHub, наследуемый
от класса Hub, предоставляемым библиотекой SignalR. Вообще говоря, причиниой разделения обязанностей отправке сообщений / получения сообщений 
было то, что у Hub очень малый срок жизни (в течении одного запроса), очевидно его нельзя использовать для отправки сообщений с сервера.
Для того, чтобы разделить логику в RoomHub и вообще не нарушать [принципа единственной ответственности](https://en.wikipedia.org/wiki/Single_responsibility_principle), был написан вспомогательный класс PlayerManager, который, как понятно из названия, работает
с конкретными или игроками, или группами игроков. Класс MatchMaker выполняет функцию подбора игры для игрока. Для инициализации работы с сервером
и Identity Core были написаны классы для выгрузки информации из соответствующих XML файлов Server.xml и IdentityInit.xml. В IdentityInit.xml
хранятся роли и пользователи, которые должны быть инициализированы при первом запуске сервера, ну а в Server.xml хранятся параметры сервера,
пока на данный момент там хранится только максимально допустимое число комнат на сервере. В планах добавить интерфейс для класса Game чтобы была возможность расширить
количество разновидностей правил игры в покер.

## Алгоритм работы игры
Разобъем игру на циклы. В 0 цикле игрокам раздаются карты, блайнды ставят по 50 и 100 фишек. Далее идет торговля. Если на каком-то цикле остается только один игрок, то он выиграл и весь кеш забирает себе. В цикле 1 раскрыты 3 карты, в цикле 2 раскрыты 4 карты, цикл 3 - финальный - при нем раскрыты 5 карт и вычисляется победитель. Вычисление победителя не такая уж и простая задача, как кажется на первый 
взгляд. Для каждого игрока нужно найти высшую комбинацию из 5 карт, и потом из игроков выбрать игрока/игроков (победителей может быть несколько), у которого/которых максимальная комбинация. Для решения этой задачи нужно как-то сопоставить комбинацию с каким-то числом, чтобы при этом данное отображение являлось биекцией. И конечно, такое отображение есть, и более того, достаточно 4 байт для числа (можно конечно и меньше, если удариться в байтослесарство)
чтобы представить все возможные комбинации в числовом виде. Ниже представлена информация по комбинациям, взятая из википедии.
* Роял-флэш<br/>
Роял-флэш (англ. royal flush — «королевская масть»): не является отдельной комбинацией, а является частным случаем стрит-флэша, старшим из всех возможных, и состоит из 5 старших (туз, король, дама, валет, десять) карт одной масти, например: Т♥ К♥ Д♥ В♥ 10♥.
* Стрит-флэш<br/>
Стрит-флэш (англ. straight flush — «масть по порядку»): любые пять карт одной масти по порядку, например: 9♠ 8♠ 7♠ 6♠ 5♠. Туз может начинать комбинацию для любой упорядоченной четвёрки. Самый младший стрит-флэш (от туза до пятёрки) иногда именуют «стальное колесо».
* Каре<br/>
Каре/Четвёрка/Покер (англ. four of a kind, quads — «четыре одинаковых»): четыре карты одного достоинства, например: 3♥ 3♦ 3♣ 3♠.
* Фулл-хаус<br/>
Фулл-хаус/Полный дом/Три плюс два (англ. full house, full boat — «полный дом», «полная лодка»): одна тройка и одна пара, например: 10♥ 10♦ 10♠ 8♣ 8♥.
* Флэш<br/>
Флэш (англ. flush — «масть»): пять карт одной масти, например: К♠ В♠ 8♠ 4♠ 3♠.
* Стрит<br/>
Стрит (англ. straight — «порядок») : пять карт по порядку любых мастей, например: 5♦ 4♥ 3♠ 2♦ Т♦. Туз может как начинать порядок, так и заканчивать его. В данном примере Т♦ начинает комбинацию и его достоинство оценивается в единицу, а 5♦ считается старшей картой. Самый младший стрит (от пятёрки до туза) иногда именуют «колесо», самый старший (от туза до десятки) — «Бродвей».
* Сет/Триплет/Трипс/Тройка<br/>
Сет/Триплет/Трипс/Тройка (англ. three of a kind, set — «три одинаковых», «набор»): три карты одного достоинства, например: 7♣ 7♥ 7♠ .
* Две пары<br/>
Две пары (англ. two pairs): две пары карт, например: 8♣ 8♠ 4♥ 4♣.
* Одна пара<br/>
Одна пара (англ. one pair): две карты одного достоинства, например: 9♥ 9♠.
* Старшая карта<br/>
Старшая карта (англ. high card): ни одна из вышеописанных комбинаций, например (комбинация называется «старший туз»): Т♦ 10♦ 9♠ 5♣ 4♣.


## Производительность

На моей системе (intel core i5 4590, 8gb RAM, samsung ssd EVO 850, Windows 10 ОС) небольшая задержка появилась при примерно 1000~ комнат,
в которой игра симулируется 6-ю ботами (т.е. общее число игроков равно 6000). Возможно это неплохой результат, а возможно и не совсем,
мне так и не удалось найти информацию по производительности того же PokerStars (у них, наверняка, гораздо производительнее :) ). При 2000 комнатах у сервера
появились ощутимые задержки в 5-10 секунд. Вполне возможно нужно пересмотреть структуру асинхронного подхода: очень много мест, где я 
использую lock, что негативно сказывается на производительности.

## Сторонние проекты
В репозитории также находятся проекты ConsolePoker и UnitTestConsole. ConsolePoker был написан как прототип игры в покер, но только в консоли и классы плавно перетекли с некоторыми изменениями в проект OpenPoker. UnitTestConsole использовался для юнит тестирования 
объекта игры, в частности кода вычисления числа соответствующей комбинации.
